# TKI-apoptosis_run.py 
# Automatically generated by Netflux on 10-Jan-2024 

# from Krabowska et al. (2021) 
# Creating Fig. 6 (KD and overexpression sens. analyses)
# Modified by Lavie Ngo 

#%%
import numpy as np 
from scipy.integrate import ode
from scipy.integrate import solve_ivp
from IPython.display import display 
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns 
import TKI_apoptosis 
import TKI_apoptosis_params
 
[speciesNames, tau, ymax, y0, w, n, EC50] = TKI_apoptosis_params.loadParams()
 
 #%% Run baseline simulation, SOR activation, and ROS activation

# ROS = 1
w_ros = w.copy()
w_ros[15] = 1 

# SOR = 1
w_sor = w.copy()
w_sor[4] = 1

tspan = [0, 50]

# run simulations
# t_eval = times at which to store the solution - must lie within t_span
base = solve_ivp(TKI_apoptosis.ODEfunc, tspan,  y0, args=(tau, ymax, w, n, EC50), t_eval=np.linspace(*tspan, 201))
ros = solve_ivp(TKI_apoptosis.ODEfunc, tspan,  y0, args=(tau, ymax, w_ros, n, EC50), t_eval=np.linspace(*tspan, 201))
sor = solve_ivp(TKI_apoptosis.ODEfunc, tspan,  y0, args=(tau, ymax, w_sor, n, EC50), t_eval=np.linspace(*tspan, 201))

#%% add solution to df
# base.y.T = activity levels
# columns are species (69 total)
# use melt to turn activity levels into its own column based on species
# var_name = new column based on existing column names
# reset index and make new time column
base_df = pd.DataFrame(base.y.T, index = base.t, columns = speciesNames).melt(var_name='species', value_name = 'activity', ignore_index= False).reset_index(names = 'time')

# create new column to label condition
base_df['condition'] = 'base'

ros_df = pd.DataFrame(ros.y.T, index = ros.t, columns = speciesNames).melt(var_name='species', value_name = 'activity', ignore_index= False).reset_index(names = 'time')
ros_df['condition'] = 'ROS activation'


sor_df = pd.DataFrame(sor.y.T, index = sor.t, columns = speciesNames).melt(var_name='species', value_name = 'activity', ignore_index= False).reset_index(names = 'time')
sor_df['condition'] = 'SOR activation'

# merge all conditions into one df
results = pd.concat([base_df, ros_df, sor_df])
display(results) # print df


#%% graph activity levels of species based on three conditions 
# choose species of interest based on paper (Fig. 2b)

species_2b = ['ROS', 'Bax', 'Bcl2', 'cas3', 'cas9', 'cytc', 'PARP', 'PUMA', 'Smac', 'xIAP']

activity_levels = sns.relplot(
    data = results,
    kind = 'line',
    x = 'time', y = 'activity',
    hue = 'species', hue_order = species_2b,
    style = 'condition',
    row = 'species', row_order = species_2b,
    height = 1.5, aspect = 3
)

#%% species activity levels based on conditions
# re-pivot results table to organize by species
results_by_species = results.pivot(index=('time', 'species'), columns = 'condition').reset_index()

# difference in activities between ros condition and baseline
results_by_species['activity', 'ros_diff'] = results_by_species['activity', 'ROS activation'] - results_by_species['activity', 'base']

# between SOR activation and baseline levels
results_by_species['activity', 'sor_diff'] = results_by_species['activity', 'SOR activation'] - results_by_species['activity', 'base']

# steady state levels
# tspan[1] = last time stamp 
steady_states = results_by_species[results_by_species['time'] == tspan[1]]

#%% Plotting steady state differences of species of interest (Fig 2b) due to ROS activation
steady_diff = sns.catplot(
    data = steady_states,
    kind = 'bar',
    x = 'species', y = ('activity', 'ros_diff'),
    order = species_2b,
    hue_order = species_2b,
    hue = 'species',
    height = 2.5, aspect = 2
)

#%% Fig 3a - time diff course of proteins based on SOR activation
# pivot table based on species and time due to sor activation
# filter down to species of interest
results_by_time = results_by_species.pivot(index = 'species', columns = 'time', values=('activity','sor_diff')).loc[['Bad', 'Bax', 'cas9', 'cas3', 'CAD', 'PARP']]

sor_diff_time = sns.heatmap(
    data = results_by_time,
    cmap = sns.color_palette('ch:s=.25, rot=-.25', as_cmap=True),
    vmin = -1,
    vmax = 1
)

#%% (Fig 6) Sensitivity analysis (difference in activity of all species due to knockdown or overexpression)
# Knockdown of species

# step 1: run default simulation to steady state 
yend_base = base.y.T[-1,:] # grab y initial values at at steady state

# step 2: simulate sorafetinib activation
yend_treatment = sor.y.T[-1,:]
sens_treat_kd = yend_treatment # difference between drug and baseline at steady state

# step 3: simulate knockdown under baseline (SOR = 0) to change y initial values
yend_kd1 = np.zeros([len(ymax), len(ymax)])
sens_kd1 = yend_kd1
deltaP = -1 # complete knockdown

# simulating knockdowns one by one at baseline
for i in range(0, len(ymax)):
	print('Param #', str(i), 'of', str(len(ymax)))
	ymax_new = ymax.copy()
	# ymax_new = new maximum values of each species AFTER KD (0)
	ymax_new[i] = (1+deltaP)*ymax[i]
	base_kd = solve_ivp(TKI_apoptosis.ODEfunc, tspan, yend_base, args=(tau, ymax_new, w, n, EC50))
	yend_kd1[:,i] = base_kd.y.T[-1,:]


#%% step 4: KD under sorafetinib activation
yend_kd2 = np.zeros([len(ymax), len(ymax)])
sens_kd = np.zeros([len(ymax), len(ymax)]) 

for i in range(0,len(ymax)):
    print('Param #', str(i), 'of', str(len(ymax)))
    ymax_new = ymax.copy() # new y values after KD
    ymax_new[i] = (1+deltaP)*ymax[i] # perform KD 
    
	# use baseline steady state values KD as y0 for sor knockdown
    treatment_kd = solve_ivp(TKI_apoptosis.ODEfunc, tspan, yend_kd1[:,i], args=(tau, ymax_new, w_sor, n, EC50))
    yend_kd2[:,i] = treatment_kd.y.T[-1,:] # KD y-values of each species at steady state (last time point)
    
	# change in activity for each species (KD at steady state with sor - treatment at steady state)
    sens_kd[:,i] = (yend_kd2[:,i]-sens_treat_kd)


# %% plot sensitivity matrix
sens_kd = np.real(sens_kd)
# heatmap params
vcenter = 0
vmin, vmax = sens_kd.min(), sens_kd.max()

plt.figure(figsize=(20,16))
sns.heatmap(sens_kd, annot = False, cmap = 'vlag', vmin = vmin, vmax = vmax, xticklabels=speciesNames, yticklabels=speciesNames)
plt.xlabel('Node Knockdown', fontsize = 20)
plt.ylabel('Measured Node Activity', fontsize = 20)

# %% Sensitivity analysis: Overexpression of each node 

# Step 1: Run default simulation to steady state
yend_base = base.y.T[-1,:] # grab y initial values at at steady state

# Step 2: Simulate sorafenib to grab steady state values
# Remember to take steady state values of baseline stimulation to replace as y0 in next simulation!
yend_over1 = np.zeros([len(ymax), len(ymax)])
yend_treatment = sor.y.T[-1,:]
sens_treat_over = yend_treatment # difference between drug and baseline at steady state

# Step 3: Simulate overexpression of each species at baseline
for i in range(0, len(ymax)):
	print('Param #', str(i), 'of', str(len(ymax)))
	tau_new = tau.copy()
	# tau_new = new time constant values of each species 
	tau_new[i] = (1000000)*tau[i]
	# new y0 values for overexpression
	yend_overexp1 = yend_base.copy()
	yend_overexp1[i] = 1; # replaces y0 values for each species
	base_kd = solve_ivp(TKI_apoptosis.ODEfunc, tspan, yend_overexp1, args=(tau_new, ymax, w, n, EC50))
	yend_over1[:,i] = base_kd.y.T[-1,:]

#%% Step 4: simulating overexpression of each species with sorafenib stimulation
yend_over2 = np.zeros([len(ymax), len(ymax)])
sens_over = np.zeros([len(ymax), len(ymax)]) 

for i in range(0,len(ymax)):
	print('Param #', str(i), 'of', str(len(ymax)))
	tau_new = tau.copy()
	tau_new[i] = 1000000 * tau[i]

	yend_overexp2 = yend_over1.copy() 
	yend_overexp2[:,i] = 1 # replace y initial values with 1 
	
	treatment_over = solve_ivp(TKI_apoptosis.ODEfunc, tspan, yend_overexp2[:,i], args=(tau_new, ymax, w_sor, n, EC50))
	yend_over2[:,i] = treatment_over.y.T[-1,:] # KD y-values of each species at steady state (last time point)
    
	# change in activity for each species (overexp at steady state with sor - treatment at steady state)
	sens_over[:,i] = (yend_over2[:,i]-sens_treat_over)

# %% plot sensitivity matrix (overexpression)
sens_over = np.real(sens_over)
# heatmap params
vcenter = 0
vmin, vmax = sens_over.min(), sens_over.max()

plt.figure(figsize=(20,16))
sns.heatmap(sens_over, annot = False, cmap = 'vlag', vmin = vmin, vmax = vmax, xticklabels=speciesNames, yticklabels=speciesNames)
plt.xlabel('Node Overexpression', fontsize = 20)
plt.ylabel('Measured Node Activity', fontsize = 20)

# %% Sensitvity analysis: Partial knockdown of pos. regulator + Partial overexpression of neg. regulator
# Partial = to see which combinations result in the most activity change across species (such as apoptosis)

neg_regs = ['Bax','CAD','cas3','MOMP','ROS','ASK1','JNK','MEK47','p53','AP1','Smac','cas9']
pos_regs = ['iCAD','PARP','NRG1','IGF1','EGF','Akt','EGFR','ERBB','IGF1R','FLT3','FGFR','PDGFR','VEGFR','KIT','PI3K','PDK1','Trx','xIAP']


# Get indexes of positive and negative regulators in SpeciesNames list to change their y-max values  
neg_index = [speciesNames.index(item) for item in neg_regs]
pos_index = [speciesNames.index(item) for item in pos_regs]

# Step 1: Run default simulation to steady state
default_base = solve_ivp(TKI_apoptosis.ODEfunc, tspan,  y0, args=(tau, ymax, w, n, EC50))
yend_base = default_base.y.T[-1,:] # grab y initial values at at steady state

# Step 2: Run simulation of SOR activation (subsituting baseline steady state values as new y0 values)
sor = solve_ivp(TKI_apoptosis.ODEfunc, tspan,  yend_base, args=(tau, ymax, w_sor, n, EC50))

yend_treatment = sor.y.T[-1,:]
sens_treatment = sor.y.T[-1,2] # apoptosis sensitivity only
 
#%% Step 3: Perform partial knockdowns + overexpression
yend1 = np.zeros([len(ymax), len(pos_index)])
yend2 = np.zeros([len(ymax), len(pos_index)])
sens_combo = np.zeros([len(neg_index), len(pos_index)])
deltaP = -0.25 # partial knockdown of pos. regulators

# For each row (negative regulator), perform knockdown of positive regulators.
for i in range(len(neg_index)): # overexpression of negative regulators from 0 to 0.25
	print('Param #', str(i), 'of', str(len(neg_index)))
	ymax_new = ymax.copy()
	ymax_new[neg_index[i]] = (1+deltaP)*ymax[neg_index[i]] # setting y_max 0.75

	# Running for each positive regulator (loop through each column)
	for j in range(len(pos_index)): # knockdown of positive regulators to y_max = 0.75
		print('Param #', str(j), 'of', str(len(pos_index)))

		# changing tau of positive regulators to 1000
		tau_new = tau.copy()
		tau_new[pos_index[j]] = 1000000 * tau[pos_index[j]]

		yend_base_new = yend_base.copy()
		yend_base_new[pos_index[j]] = 0.25 # changing y0 one by one

		# Run baseline stimulation using y0 as 0.25 for each species (overexpression)
		pos_kd = solve_ivp(TKI_apoptosis.ODEfunc, tspan, yend_base_new, args=(tau_new, ymax_new, w, n, EC50))
		yend1[:,j] = pos_kd.y.T[-1,:]

		#Turn on SOR (w_sor = 1 as parameter)
		yend1_new = yend1.copy()
		yend1_new[pos_index[j]] = 0.25 

		# Second stimulation with SOR activated with y0 values as the steady state values of the last simulation
		# We are increasing from 0 to 0.25 still 
		# Perform for all species
		pos_kd2 = solve_ivp(TKI_apoptosis.ODEfunc, tspan, yend1_new[:,j], args=(tau_new, ymax_new, w_sor, n, EC50))
		
		# Looking for change in apoptosis - baseline 
		change_apop = ((pos_kd2.y.T[-1,2])-sens_treatment)
		
		# fill sensitivity matrix: row = negative, col = positive)
		sens_combo[i,j] = change_apop

# %% Plot sensitivity matrix (combination)
sens_combo = np.real(sens_combo)
# heatmap params
vcenter = 0
vmin, vmax = sens_combo.min(), sens_combo.max()


plt.figure(figsize=(20,16))
sns.heatmap(sens_combo, cmap = 'Blues', annot = False, vmin = vmin, vmax = vmax, xticklabels=pos_regs, yticklabels=neg_regs)
plt.xlabel('Overexpression of Positive Regulators', fontsize = 20)
plt.ylabel('Knockdown of Negative Regulators', fontsize = 20)


# %%
