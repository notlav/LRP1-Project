# TKI-apoptosis_run.py 
# Automatically generated by Netflux on 10-Jan-2024 

# from Krabowska et al. (2021) 
# Creating Fig. 7 (Combo screen of positive and negative regulators)
# Modified by Lavie Ngo 

#%%
import numpy as np 
from scipy.integrate import ode
from scipy.integrate import solve_ivp
from IPython.display import display 
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns 
import TKI_apoptosis 
import TKI_apoptosis_params
 
[speciesNames, tau, ymax, y0, w, n, EC50] = TKI_apoptosis_params.loadParams()

tspan = [0, 50]

#%% Run default simulation to steady state
y0 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, ]; 
ymax = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ];

base = solve_ivp(TKI_apoptosis.ODEfunc, tspan,  y0, args=(tau, ymax, w, n, EC50), method='RK23')
yend_base = base.y[:,-1]

# Simulate SOR = 1, replacing y0 with previous steady state y_end values
w_sor = w.copy()
w_sor[4] = 1
sor = solve_ivp(TKI_apoptosis.ODEfunc, tspan,  yend_base, args=(tau, ymax, w_sor, n, EC50))
yend_sor = sor.y[:,-1]

# Grab 3rd steady state value (for apoptosis only)
sens_sor_apop = yend_sor[2] 

# %% Sensitvity analysis: Partial knockdown of pos. regulator + Partial overexpression of neg. regulator
# Partial = to see which combinations result in the most activity change across species (such as apoptosis)

neg_regs = ['Bax','CAD','cas3','MOMP','ROS','ASK1','JNK','MEK47','p53','AP1','Smac','cas9']
pos_regs = ['iCAD','PARP','NRG1','IGF1','EGF','Akt','EGFR','ERBB','IGF1R','FLT3','FGFR','PDGFR','VEGFR','KIT','PI3K','PDK1','Trx','xIAP']

# Get indexes of positive and negative regulators in SpeciesNames list to change their y-max values  
neg_index = [speciesNames.index(item) for item in neg_regs]
pos_index = [speciesNames.index(item) for item in pos_regs]

#%% Run default simulation to steady state
base = solve_ivp(TKI_apoptosis.ODEfunc, tspan,  y0, args=(tau, ymax, w, n, EC50))
yend_base = base.y[:,-1]

#%% Perform partial knockdowns + overexpression
yend1 = np.zeros([len(ymax), len(pos_index)])
yend2 = np.zeros([len(ymax), len(pos_index)])
sens_combo = np.zeros([len(neg_index), len(pos_index)])
deltaP = -0.25 # partial knockdown of pos. regulators

# For each row (negative regulator), perform knockdown of positive regulators.
for i in range(len(neg_index)): # overexpression of negative regulators from 0 to 0.25
	print('Param #', str(i), 'of', str(len(neg_index)))
	ymax_new = np.transpose(ymax.copy())

	# CONVERT NP ARRAY LIST INTO FLOAT FIRST (IT WILL REPLACE 0.75 AS 0 IF YOU DON'T)!
	ymax_new = ymax_new.astype(float)
	
	ymax_new[neg_index[i]] = (1+deltaP) * ymax[neg_index[i]] # setting y_max 0.75
	

	#Running for each positive regulator (loop through each column)
	for j in range(len(pos_index)): # knockdown of positive regulators to y_max = 0.75
		print('Param #', str(j), 'of', str(len(pos_index)))

		# changing tau of positive regulators to 1000
		tau_new = tau.copy()
		tau_new[pos_index[j]] = 1000000 * tau[pos_index[j]]

		yend_base_new = yend_base.copy()
		yend_base_new[pos_index[j]] = 0.25 # changing y0 one by one

		# Run baseline stimulation using y0 as 0.25 for each species (overexpression)
		pos_kd = solve_ivp(TKI_apoptosis.ODEfunc, tspan, yend_base_new, args=(tau_new, ymax_new, w, n, EC50), method = 'RK23', t_eval=np.linspace(*tspan, 201))
		yend1[:,j] = np.transpose(pos_kd.y)[-1,:]

		#Turn on SOR (w_sor = 1 as parameter)
		w[4] = 1
		yend1_new = yend1.copy()
		yend1_new[pos_index[j],0] = 0.25 

		pos_kd2 = solve_ivp(TKI_apoptosis.ODEfunc, tspan, yend1_new[:,j], args=(tau_new, ymax_new, w, n, EC50), method = 'RK23', t_eval=np.linspace(*tspan, 201))
		
		#Looking for change in apoptosis - baseline 
		change_apop = ((np.transpose(pos_kd2.y[:,-1][2]))-sens_sor_apop)
		
		# fill sensitivity matrix: row = negative, col = positive)
		sens_combo[i,j] = change_apop

# %% Plot sensitivity matrix (combination)
sens_combo = np.real(sens_combo)
# heatmap params
vmin, vmax = -1, 0


sns.heatmap(sens_combo, annot = False, cmap = 'Blues_r', vmin = vmin, vmax = vmax, xticklabels=pos_regs, yticklabels=neg_regs)
plt.xlabel('Overexpression of Positive Regulators', fontsize = 10)
plt.ylabel('Knockdown of Negative Regulators', fontsize = 10)


# %%
